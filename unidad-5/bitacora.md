# Bit√°cora de aprendizaje de la unidad 5

## 1.  **Diagn√≥stico inicial**
- Estoy medio olvidado y perdido con todos los temas de POO
- Creo que voy mejorando con los temas pero me confundo a√∫n, igual, identifico mejor el polimorfismo y la encapsulaci√≥n, me cuesta menos distinguirla

## 2.  **La pregunta inicial**
- ¬øC√≥mo podr√© recordar los conceptos de herencia y polimorfismo para volverlos a aplicar al nuevo contexto?

## 3.  **Registro de exploraci√≥n:** 
- Aqu√≠ documentas cada ciclo de pregunta -> hip√≥tesis -> experimento -> hallazgo -> reflexi√≥n.
- Debe ser rico en evidencia visual (c√≥digo, capturas del depurador con anotaciones, diagramas).

# Actividad 1

## Parte 1: recordando los conceptos (en C#)

¬øQu√© es el encapsulamiento para ti? Describe una situaci√≥n en la que te haya sido √∫til o donde hayas visto su importancia.
- La encapsulaci√≥n en Java es un principio que consiste en agrupar y m√©todos de un objeto dentro de una sola clase para poderse controlar desde una interfaz
- Recuerdo alguna vez haber utilizado encapsulamiento para determinar si los productos de un supermercado ficticio ten√≠an tipos de clasificaciones que se pudieran cambiar o no por un m√©todo que se llamaba con input del usuario.
¬øQu√© es la herencia? ¬øPor qu√© un programador decidir√≠a usarla? Da un ejemplo simple.
- La herencia es cuando creas una clase derivada de otra clase que ya exist√≠a y esta toma sus atributos como suyos junto a otros espec√≠ficos a esa sub clase. Es super √∫til para cosas como objetos con anomal√≠as ligeras de una taxonom√≠a o clasificar especies de animales por ejemplo
- Ejemplo:
``` C++
#include <iostream>
using namespace std;

// Clase base
class Animal {
public:
    void comer() {
        cout << "El animal est√° comiendo." << endl;
    }

    void dormir() {
        cout << "El animal est√° durmiendo." << endl;
    }
};

// Clase derivada
class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro est√° ladrando." << endl;
    }
};

int main() {
    Perro miPerro;

    // M√©todos heredados de Animal
    miPerro.comer();
    miPerro.dormir();

    // M√©todo propio de Perro
    miPerro.ladrar();

    return 0;
}
```
¬øQu√© es el polimorfismo? Describe con tus palabras qu√© significa que un c√≥digo sea ‚Äúpolim√≥rfico‚Äù.
- Que podemos escribir c√≥digo que trabaje con objetos de distintas clases de forma uniforme, sin importar su tipo espec√≠fico, siempre y cuando compartan una interfaz com√∫n. Esto hace que el c√≥digo sea m√°s flexible y extensible.

## Parte 2: An√°lisis de c√≥digo
*Encapsulamiento/

- Ejemplo de encapsulamiento:

``` public string Nombre
{
    get { return nombre; }
    protected set { nombre = value; }
}
```

Aqu√≠ nombre est√° declarado como private, pero se expone por la propiedad Nombre.
Esto es encapsulamiento porque el detalle interno queda oculto.

- ¬øPor qu√© nombre es private y Nombre es public?

Porque as√≠ evitas que desde afuera se pueda cambiar libremente
La propiedad Nombre controla c√≥mo se accede: getter p√∫blico pero escritura setter solo permitido dentro de su propia clase o clases hijas.

**Herencia**

- ¬øC√≥mo se evidencia la herencia en Circulo?

```
public class Circulo : Figura
```

El : Figura es que Circulo hereda de Figura.
Gracias a eso, Circulo puede usar el constructor de Figura (base("C√≠rculo")) y agrega el m√©todo Dibujar().

- Adem√°s de Radio, qu√© datos almacena Circulo?

Gracias a heredar de Figura, tambi√©n tiene el campo nombre (a trav√©s de la propiedad Nombre).
O sea, internamente un Circulo tiene:

Radio
Nombre

**Polimorfismo**

- C√≥mo creo que funciona por debajo:

Quiz√° cada clase tenga como una "tabla" interna de direcciones de memoria que le diga qu√© es qu√© y as√≠.
Cuando llamas a Dibujar, el programa busca en esa tabla cu√°l es el C√≥digo o funci√≥n que le debe meter al objeto de esa clase y salta a ese C√≥digo, como un indicador.

## Parte 3: Hip√≥tesis sobre la implementaci√≥n
**Memoria y herencia**
- Me imagino que el Nombre ir√≠a primero, como designante de toda la instanciaci√≥n, despu√©s de sus atributos que tomar√≠an herencia de una superclase


**Mecanismo del polimorfismo**
- Yo pensar√≠a que si no hay variable de booleano que determine que si es rect√°ngulo true o elseif c√≠rculo o una string, entonces quiz√° podr√≠a detectarlo basado en si tiene atributos de herencia "radio" o "base, altura".

**La barrera del encapsulamiento**
- Yo creo que la protecci√≥n private se revisa principalmente en compilaci√≥n. El compilador ya sabe qu√© miembros son accesibles desde d√≥nde y te da error si intentas romper la regla.

## Parte 4: Autoevaluaci√≥n y primeras preguntas

Encapsulamiento: entend√≠ que sirve para proteger el estado interno de un objeto.
Herencia: vi c√≥mo los objetos ‚Äúheredan‚Äù no solo m√©todos, sino tambi√©n datos.
Polimorfismo: razon√© que hay alg√∫n mecanismo interno (tipo tabla de funciones) que hace posible que Dibujar() se resuelva din√°micamente.

Primera pregunta para iniciar mi ruta personal:
- ¬øC√≥mo se ve en la memoria un objeto con herencia en C#?


# Actividad 2

## ¬øQu√© identifiqu√©?

Particle Es una clase abstracta, todas las part√≠culas deben poder tener update(), draw(), decir si est√°n muertas (isDead()) y, en el caso de las que suben, indicar si deben explotar (shouldExplode()).

RisingParticle es la chispa que se va agrandando. Nace en la parte de abajo de la pantalla, con una velocidad que la impulsa hacia arriba., su movimiento se va frenando por la gravedad y al llegar a una altura se flaggea que ya puede explotar

Clases de explosi√≥n: (CircularExplosion, RandomExplosion, StarExplosion)

Cuando una RisingParticle explota, genera entre 20 y 30 part√≠culas de explosi√≥n.
- CircularExplosion -> dibuja c√≠rculo
- RandomExplosion -> dibuja rect√°ngulos
- StarExplosion -> dibuja l√≠neas que forman una estrellita

- Con click -> crea una chispa que sube (RisingParticle).
- Con espacio -> crea 1000 part√≠culas como de la nada
- Con tecla s -> guarda una captura de pantalla.


# Actividad 3

## dep


# Actividad 4

## Cod. 1
publicVar se puede modificar sin problema.
protectedVar y privateVar no deber√≠an poder modificarse directamente desde main().
El compilador deber√≠a lanzar un error de acceso.
El encapsulamiento funciona en tiempo de compilaci√≥n: el compilador impide que un c√≥digo externo acceda a variables privadas o protegidas.


## Cod. 2
El compilador no permitir√° el acceso a obj.secret1 porque es private.
error: 'int MyClass::secret1' is private within this context


## Cod. 3
Aunque secret1, secret2 y secret3 son privados, el reinterpret_cast deja caer a la memoria de obj y leerlos directamente.
El programa compila y ejecuta sin errores.


## Conclusi√≥n
El encapsulamiento NO es una barrera real en tiempo de ejecuci√≥n.
En C++, un objeto es un bloque de memoria contiguo y usando punteros puedes saltarte las restricciones.
Lo que hace el compilador es proteger en el c√≥digo fuente, no blindar f√≠sicamente la memoria.

## ¬øQu√© es el encapsulamiento?
El encapsulamiento es ocultar los atributos internos de una clase y exponer solo lo necesario a al instanciar con publics, privates y protecteds.

## ¬øPor qu√© es importante?
Permite proteger los datos de modificaciones accidentales.
Asegura que el objeto solo se use de la forma que el programador dise√±√≥.
Facilita el mantenimiento y la reutilizaci√≥n del c√≥digo.


# Actividad 5

## CircularExplosion en memoria

Al inspeccionar el objeto CircularExplosion en el depurador se observa que:
- El objeto contiene los campos heredados de Particle, luego los campos a√±adidos por ExplosionParticle, y finalmente los propios de CircularExplosion.
- En la ventana Locals/Autos se refleja la jerarqu√≠a de clases expandida en √°rbol, y en Memory se ve como un bloque contiguo de direcciones.
- El primer campo corresponde al puntero a la vtable, lo que confirma el soporte de m√©todos virtuales.
Conclusi√≥n: la herencia se materializa en memoria como un √∫nico bloque que conecta las clases base y la clase derivada

## ¬øC√≥mo se implementa la herencia en C++?
El compilador organiza la memoria de la clase derivada colocando primero los miembros de la clase base y luego los nuevos de la derivada.
Si existen m√©todos virtuales, se a√±ade un puntero oculto a la _vtable que permite el polimorfismo.

## Experimento de herencia m√∫ltiple

Ejemplo:
``` c++
#include <iostream>
using namespace std;

class A { public: int a; A() : a(1) {} };
class B { public: int b; B() : b(2) {} };
class C : public A, public B { public: int c; C() : c(3) {} };

int main() {
    C obj;
    cout << obj.a << ", " << obj.b << ", " << obj.c << endl;
    return 0;
}


üîé En el depurador:

El objeto obj aparece dividido en bloques: primero la parte de A, luego la parte de B, y finalmente los campos propios de C.
En memoria se ve como la concatenaci√≥n de las estructuras de A, B y C.

Conclusi√≥n: en C++ la herencia m√∫ltiple se implementa agregando cada clase base como una secci√≥n distinta dentro del mismo objeto. Esto permite combinar varias jerarqu√≠as, aunque puede producir ambig√ºedades (por ejemplo, el problema del diamante), que se resuelven con herencia virtual.

```
